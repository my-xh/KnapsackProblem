"""
问题描述
玛莎（Marsha）和比尔（Bill）拥有一系列大理石。他们希望将藏品分开，以使两者获得相等的份额。如果所有的大理石都具有相同的价值，这将很容易，因为那样他们就可以将收藏品分成两半。
但不幸的是，有些大理石比其他大理石更大或更漂亮。因此，玛莎（Marsha）和比尔（Bill）首先为每个大理石分配一个值，即一个介于1到6之间的自然数。
现在，他们希望对大理石进行分割，以使每个大理石都获得相同的总价值。不幸的是，他们意识到以这种方式分割大理石可能是不可能的（即使所有大理石的总价值是均匀的）。
例如，如果存在一个值为1的大理石，值为3的一个，值为4的两个，则不能将它们拆分为相等值的集合。因此，他们要求您编写一个程序来检查大理石是否存在合理的分区。
 

输入
输入中的每一行都描述了一组要分割的大理石。每一行由六个非负整数n1，n2，...，n6组成，其中ni是值i的大理石数。因此，上面的示例将由输入行``1 0 1 2 0 0''描述。大理石的最大总数为20000。

输入文件的最后一行将为“ 0 0 0 0 0 0”；不要处理此行。

输出
对于每个集合，输出"集合k:"，其中k是测试用例的编号，然后是``可以被分割"或``不能被分割''。

在每个测试用例之后输出空白行。
 

样本输入
1 0 1 2 0 0
1 0 0 0 1 1
0 0 0 0 0 0
 

样本输出
集合1：
不能被分割

集合2：
可以被分割
"""


S = []
print('输入:')
while True:
    s = input()
    if s == '0 0 0 0 0 0':
        break
    S.append(s)

print('\n输出:')
w = [1, 2, 3, 4, 5, 6]
for k in range(len(S)):
    p = [int(i) for i in S[k].split()]
    _sum = sum(i * j for i, j in zip(w, p))
    if _sum % 2 != 0:
        print(f'集合{k + 1}:\n不能被分割')
        continue
    V = _sum // 2

    n = len(w)
    dp = [False] * (V + 1)
    dp[0] = True    # 只有0件物品能达到0价值

    for i in range(n):
        num, total = 1, p[i]
        while total > 0:
            if num > total:
                num = total
            group_w = w[i] * num
            for j in range(V, group_w - 1, -1):
                dp[j] = dp[j - group_w]
            total -= num
            num <<= 1

    if dp[V]:
        print(f'集合{k + 1}:\n可以被分割')
    else:
        print(f'集合{k + 1}:\n不能被分割')
